{"version":3,"sources":["../../../../src/application/ecommerce/use-case/checkout-complete.ts"],"sourcesContent":["import { Injectable, RawBodyRequest } from '@nestjs/common';\nimport { Request } from 'express';\nimport { PaymentRepository } from '../ports/payment.repositoy';\nimport { Order } from '@app/domain/ecommerce/order';\n\ntype CheckoutCompleteUseCaseCommand = {\n  headers: Request['headers'],\n  req: RawBodyRequest<Request>\n}\n\n@Injectable()\nexport class CheckoutCompleteUseCase {\n  constructor(\n    private paymentRepository: PaymentRepository,\n  ) { }\n\n  /*\n    * This method is not abstracted, but it is a good example of how to handle webhooks in a controller.\n    */\n  async execute({ headers, req }: CheckoutCompleteUseCaseCommand): Promise<Order> {\n    const signature = headers['stripe-signature'];\n\n    if (!signature) {\n      throw new Error('Invalid signature');\n    }\n\n    const order = await this.paymentRepository.complete({\n      signature,\n      req: req.rawBody,\n    });\n\n    return order;\n  }\n}\n"],"names":["CheckoutCompleteUseCase","execute","headers","req","signature","Error","order","paymentRepository","complete","rawBody","constructor","Injectable"],"mappings":";;;;+BAWaA;;;eAAAA;;;wBAX8B;kCAET;;;;;;;;;;AAS3B,IAAA,AAAMA,0BAAN,MAAMA;IAKX;;IAEE,GACF,MAAMC,QAAQ,EAAEC,OAAO,EAAEC,GAAG,EAAkC,EAAkB;QAC9E,MAAMC,YAAYF,OAAO,CAAC,mBAAmB;QAE7C,IAAI,CAACE,WAAW;YACd,MAAM,IAAIC,MAAM;QAClB;QAEA,MAAMC,QAAQ,MAAM,IAAI,CAACC,iBAAiB,CAACC,QAAQ,CAAC;YAClDJ;YACAD,KAAKA,IAAIM,OAAO;QAClB;QAEA,OAAOH;IACT;IApBAI,YACE,AAAQH,iBAAoC,CAC5C;aADQA,oBAAAA;IACN;AAmBN;AAtBaP;IADZW,IAAAA,kBAAU;;;eAGoB,mCAAiB,4BAAjB,mCAAiB;;GAFnCX"}