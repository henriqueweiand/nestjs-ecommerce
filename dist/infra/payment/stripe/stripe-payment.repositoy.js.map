{"version":3,"sources":["../../../../src/infra/payment/stripe/stripe-payment.repositoy.ts"],"sourcesContent":["import { OrderRepository } from \"@app/application/ecommerce/ports/order.repositoy\";\nimport { PaymentRepository } from \"@app/application/ecommerce/ports/payment.repositoy\";\nimport { EnvService } from \"@app/infra/env\";\nimport { Injectable } from \"@nestjs/common\";\nimport Stripe from \"stripe\";\nimport { StripeService } from \"./stripe.service\";\nimport { Order } from \"@app/domain/ecommerce/order\";\n\n@Injectable()\nexport class StripePaymentRepository implements PaymentRepository {\n  private stripe: Stripe;\n\n  constructor(\n    private orderRepository: OrderRepository,\n    private stripeService: StripeService,\n    private envService: EnvService\n  ) {\n    this.stripe = this.stripeService.getInstance();\n  }\n\n  async generateUrl(orderId: string): Promise<string> {\n    const order = await this.orderRepository.findById(orderId);\n    const settingsUrl = this.envService.get(\"CHECKOUT_SUCCESS_URL\");\n\n    if (!order) {\n      throw new Error(\"Order not found\");\n    }\n\n    const stripeSession = await this.stripe.checkout.sessions.create({\n      success_url: settingsUrl,\n      cancel_url: settingsUrl,\n      payment_method_types: [\"card\"],\n      mode: \"payment\",\n      billing_address_collection: \"auto\",\n      // customer_email: 'test@gmail.com', // this system doesn't have email\n      line_items: order.orderProduct.map((item) => {\n        return {\n          price_data: {\n            currency: \"USD\",\n            product_data: {\n              name: item.product,\n            },\n            unit_amount: item.price * 100,\n          },\n          quantity: 1,\n        };\n      }),\n      metadata: {\n        orderId: order.id,\n      },\n    });\n\n    return stripeSession.url || \"\";\n  }\n\n  private constructEvent({\n    req,\n    signature,\n  }: {\n    req: string | Buffer,\n    signature: string,\n  }): Stripe.Event {\n    let event: Stripe.Event;\n\n    try {\n      event = this.stripe.webhooks.constructEvent(\n        req,\n        signature,\n        this.envService.get(\"STRIPE_WEBHOOK_SECRET\")\n      );\n    } catch (error) {\n      throw new Error(\"Webhook error\");\n    }\n\n    return event;\n  }\n\n  async complete(orderData: any): Promise<Order> {\n    const event = this.constructEvent(orderData);\n    const session = event.data.object as Stripe.Checkout.Session;\n\n    if (event.type === \"checkout.session.completed\") {\n      try {\n        const paymentIntentId = await this.stripe.checkout.sessions.retrieve(session.id);\n\n        const orderId = session?.metadata?.orderId;\n\n        if (!orderId) {\n          throw new Error(\"Invalid event: orderId not found\");\n        }\n\n        const order = await this.orderRepository.findById(orderId);\n\n        if (order.status === \"paid\") {\n          throw new Error(\"Order already paid\");\n        }\n\n        const updatedOrder = await this.orderRepository.update(\n          orderId,\n          new Order({\n            ...order.currentState,\n            status: 'paid',\n            paymentId: paymentIntentId.id,\n            paymentMethod: \"stripe\",\n          })\n        );\n\n        return updatedOrder;\n      } catch (error) {\n        throw new Error(\"Invalid event: subscription not found\");\n      }\n    }\n\n  }\n}"],"names":["StripePaymentRepository","generateUrl","orderId","order","orderRepository","findById","settingsUrl","envService","get","Error","stripeSession","stripe","checkout","sessions","create","success_url","cancel_url","payment_method_types","mode","billing_address_collection","line_items","orderProduct","map","item","price_data","currency","product_data","name","product","unit_amount","price","quantity","metadata","id","url","constructEvent","req","signature","event","webhooks","error","complete","orderData","session","data","object","type","paymentIntentId","retrieve","status","updatedOrder","update","Order","currentState","paymentId","paymentMethod","constructor","stripeService","getInstance","Injectable"],"mappings":";;;;+BASaA;;;eAAAA;;;gCATmB;qBAEL;wBACA;+BAEG;uBACR;;;;;;;;;;AAGf,IAAA,AAAMA,0BAAN,MAAMA;IAWX,MAAMC,YAAYC,OAAe,EAAmB;QAClD,MAAMC,QAAQ,MAAM,IAAI,CAACC,eAAe,CAACC,QAAQ,CAACH;QAClD,MAAMI,cAAc,IAAI,CAACC,UAAU,CAACC,GAAG,CAAC;QAExC,IAAI,CAACL,OAAO;YACV,MAAM,IAAIM,MAAM;QAClB;QAEA,MAAMC,gBAAgB,MAAM,IAAI,CAACC,MAAM,CAACC,QAAQ,CAACC,QAAQ,CAACC,MAAM,CAAC;YAC/DC,aAAaT;YACbU,YAAYV;YACZW,sBAAsB;gBAAC;aAAO;YAC9BC,MAAM;YACNC,4BAA4B;YAC5B,sEAAsE;YACtEC,YAAYjB,MAAMkB,YAAY,CAACC,GAAG,CAAC,CAACC;gBAClC,OAAO;oBACLC,YAAY;wBACVC,UAAU;wBACVC,cAAc;4BACZC,MAAMJ,KAAKK,OAAO;wBACpB;wBACAC,aAAaN,KAAKO,KAAK,GAAG;oBAC5B;oBACAC,UAAU;gBACZ;YACF;YACAC,UAAU;gBACR9B,SAASC,MAAM8B,EAAE;YACnB;QACF;QAEA,OAAOvB,cAAcwB,GAAG,IAAI;IAC9B;IAEQC,eAAe,EACrBC,GAAG,EACHC,SAAS,EAIV,EAAgB;QACf,IAAIC;QAEJ,IAAI;YACFA,QAAQ,IAAI,CAAC3B,MAAM,CAAC4B,QAAQ,CAACJ,cAAc,CACzCC,KACAC,WACA,IAAI,CAAC9B,UAAU,CAACC,GAAG,CAAC;QAExB,EAAE,OAAOgC,OAAO;YACd,MAAM,IAAI/B,MAAM;QAClB;QAEA,OAAO6B;IACT;IAEA,MAAMG,SAASC,SAAc,EAAkB;QAC7C,MAAMJ,QAAQ,IAAI,CAACH,cAAc,CAACO;QAClC,MAAMC,UAAUL,MAAMM,IAAI,CAACC,MAAM;QAEjC,IAAIP,MAAMQ,IAAI,KAAK,8BAA8B;YAC/C,IAAI;gBACF,MAAMC,kBAAkB,MAAM,IAAI,CAACpC,MAAM,CAACC,QAAQ,CAACC,QAAQ,CAACmC,QAAQ,CAACL,QAAQV,EAAE;gBAE/E,MAAM/B,UAAUyC,SAASX,UAAU9B;gBAEnC,IAAI,CAACA,SAAS;oBACZ,MAAM,IAAIO,MAAM;gBAClB;gBAEA,MAAMN,QAAQ,MAAM,IAAI,CAACC,eAAe,CAACC,QAAQ,CAACH;gBAElD,IAAIC,MAAM8C,MAAM,KAAK,QAAQ;oBAC3B,MAAM,IAAIxC,MAAM;gBAClB;gBAEA,MAAMyC,eAAe,MAAM,IAAI,CAAC9C,eAAe,CAAC+C,MAAM,CACpDjD,SACA,IAAIkD,YAAK,CAAC;oBACR,GAAGjD,MAAMkD,YAAY;oBACrBJ,QAAQ;oBACRK,WAAWP,gBAAgBd,EAAE;oBAC7BsB,eAAe;gBACjB;gBAGF,OAAOL;YACT,EAAE,OAAOV,OAAO;gBACd,MAAM,IAAI/B,MAAM;YAClB;QACF;IAEF;IArGA+C,YACE,AAAQpD,eAAgC,EACxC,AAAQqD,aAA4B,EACpC,AAAQlD,UAAsB,CAC9B;aAHQH,kBAAAA;aACAqD,gBAAAA;aACAlD,aAAAA;QAER,IAAI,CAACI,MAAM,GAAG,IAAI,CAAC8C,aAAa,CAACC,WAAW;IAC9C;AAgGF;AAzGa1D;IADZ2D,IAAAA,kBAAU;;;eAKkB,+BAAe,4BAAf,+BAAe;eACjB,4BAAa,4BAAb,4BAAa;eAChB,eAAU,4BAAV,eAAU;;GANrB3D"}